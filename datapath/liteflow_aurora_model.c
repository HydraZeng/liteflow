// The sample model code can be generated by configurator outside datapath

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/slab.h>

#include "linux/liteflow.h"

#define AURORA_APP_ID 2
#define AURORA_MODEL_UUID 101

#define APPRO_LEVEL 10

static s64 input_vector[6] = {1, 2, 3, 4, 5, 6};
static s64 output_vector[1];

static void aurora_layer1_comp (s64 *input, s64 *output);
static void aurora_layer2_comp (s64 *input, s64 *output);
static void aurora_layer3_comp (s64 *input, s64 *output);
s64 appro_tanh(s64 input);

struct model_container aurora_model __read_mostly = {
    .uuid = AURORA_MODEL_UUID,
    .input_size = 6,
    .output_size = 1,
};

struct model_layer aurora_layer1 __read_mostly = {
    .uuid = AURORA_MODEL_UUID + 1,
    .input_size = 6,
    .output_size = 32,
    .comp_func = aurora_layer1_comp,
};

struct model_layer aurora_layer2 __read_mostly = {
    .uuid = AURORA_MODEL_UUID + 2,
    .input_size = 32,
    .output_size = 16,
    .comp_func = aurora_layer2_comp,
};

struct model_layer aurora_layer3 __read_mostly = {
    .uuid = AURORA_MODEL_UUID + 3,
    .input_size = 16,
    .output_size = 1,
    .comp_func = aurora_layer3_comp,
};

static void construct_aurora_model(void)
{
    INIT_LIST_HEAD(&aurora_model.layers);
    list_add(&aurora_layer1.list, &aurora_model.layers);
    list_add(&aurora_layer2.list, &aurora_layer1.list);
    list_add(&aurora_layer3.list, &aurora_layer2.list);
}

static s64 mon_comp(s64 input, u32 power) {
    u32 power_times;
    s64 result = 1;

    for (power_times = 0; power_times < power; power_times++) {
        result = result * input / (power_times + 1);
    }

    return result;
}

s64 appro_tanh(s64 input)
{
    u32 power_times = 0;
    s64 sinh = 0;
    s64 cosh = 0;
    s64 result = 0;

    for (power_times = 0; power_times < APPRO_LEVEL; power_times++) {
        sinh += mon_comp(input, 2 * power_times + 1);
        cosh += mon_comp(input, 2 * power_times);
    }

    result = sinh / cosh;
    
    return result;
}

static void aurora_layer1_comp (s64 *input, s64 *output)
{
    u32 input_pos, output_pos = 0; 
    s64 temp_result = 0;
    s32 weight = 1;

    for (output_pos = 0; output_pos < 32; output_pos ++) {
        for (temp_result = 0, input_pos = 0; input_pos < 6; input_pos++) {
            temp_result += input[input_pos] * weight;
        }
        output[output_pos] = appro_tanh(temp_result);
    }
}

static void aurora_layer2_comp (s64 *input, s64 *output)
{
    u32 input_pos, output_pos = 0; 
    s64 temp_result = 0;
    s32 weight = 1;

    for (output_pos = 0; output_pos < 16; output_pos ++) {
        for (temp_result = 0, input_pos = 0; input_pos < 32; input_pos++) {
            temp_result += input[input_pos] * weight;
        }
        output[output_pos] = appro_tanh(temp_result);
    }
}

static void aurora_layer3_comp (s64 *input, s64 *output)
{
    u32 input_pos, output_pos = 0; 
    s64 temp_result = 0;
    s32 weight = 1;

    for (output_pos = 0; output_pos < 1; output_pos ++) {
        for (temp_result = 0, input_pos = 0; input_pos < 16; input_pos++) {
            temp_result += input[input_pos] * weight;
        }
        output[output_pos] = appro_tanh(temp_result);
    }
}

struct app aurora_app = {
    .appid = AURORA_APP_ID,
    .input_size = 6,
    .output_size = 1,
};

static int
__init liteflow_aurora_model_init(void)
{
    u32 pos;

    lf_register_app(&aurora_app);

    construct_aurora_model();
    lf_register_model(AURORA_APP_ID, &aurora_model);

    lf_activate_model(AURORA_APP_ID, AURORA_MODEL_UUID);
    lf_query_model(AURORA_APP_ID, input_vector, output_vector);

    printk(KERN_INFO "Sample output:\n");
    for (pos = 0; pos < 1; ++pos) {
        printk(KERN_INFO "pos %u: %lld\n", pos, output_vector[pos]);
    }

    return 0;
}

static void
__exit liteflow_aurora_model_exit(void)
{
    lf_unregister_app(AURORA_APP_ID);
}

module_init(liteflow_aurora_model_init);
module_exit(liteflow_aurora_model_exit);

MODULE_DESCRIPTION("liteflow aurora model");
MODULE_AUTHOR("Chaoliang ZENG");
MODULE_LICENSE("GPL");